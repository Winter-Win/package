1、调整数组顺序使奇数位于偶数前面
https://www.nowcoder.com/practice/beb5aa231adc45b2a5dcc5b62c93f593?tpId=13&tqId=11166&tPage=1&rp=1&ru=/ta/coding-interviews&qru=/ta/coding-interviews/question-ranking

输入一个整数数组，实现一个函数来调整该数组中数字的顺序，使得所有的奇数位于数组的前半部分，所有的偶数位于数组的后半部分，并保证奇数和奇数，偶数和偶数之间的相对位置不变

class Solution {
public:
    void reOrderArray(vector<int> &array) {
        //方法一：先将偶数都放在一个数组里，同时从原数组删除掉，最后再将其加在数组后面
        //但是时间复杂度和空间都有消耗
        vector<int> ret;
        auto it = array.begin();
        while(it != array.end())
        {
            if(*it % 2 == 0)
            {
                ret.push_back(*it);
                array.erase(it);
            }
            else
            {
                it++;
            }
        }
        
        for(auto e : ret)
        {
            array.push_back(e);
        }
    }
};



class Solution {
public:
    void reOrderArray(vector<int> &array) {
        //方法二：类似于冒泡排序，从前往后，如果遇到相邻的先偶后奇就交换位置
        //或者从后往前冒泡，如果遇到相邻的前偶后奇就交换位置
        for(size_t i = 0; i < array.size(); ++i)
        {
            //控制j > i,减少遍历次数
            for(size_t j = array.size() - 1; j > i; --j)
            {
                if(array[j] % 2 == 1 && array[j - 1] % 2 == 0)
                    swap(array[j], array[j-1]);
            }
        }
    }
};



2、最小的K个数
https://www.nowcoder.com/practice/6a296eb82cf844ca8539b57c23e6e9bf?tpId=13&tqId=11182&tPage=2&rp=1&ru=%2Fta%2Fcoding-interviews&qru=%2Fta%2Fcoding-interviews%2Fquestion-ranking

输入n个整数，找出其中最小的K个数。例如输入4,5,1,6,2,7,3,8这8个数字，则最小的4个数字是1,2,3,4,。

class Solution {
public:
    vector<int> GetLeastNumbers_Solution(vector<int> input, int k) {
        sort(input.begin(), input.end());
        vector<int> ret;
	//当k比数组长度还大的话，直接就是返回空，也可以包括原数组可能没数据
        if(k > input.size())
        {
            return ret;
        }
        
        for(size_t i = 0; i < k; ++i)
        {
            ret.push_back(input[i]);
        }
        return ret;
    }
};


3、旋转数组的最小数字
https://www.nowcoder.com/practice/9f3231a991af4f55b95579b44b7a01ba?tpId=13&tqId=11159&tPage=1&rp=1&ru=/ta/coding-interviews&qru=/ta/coding-interviews/question-ranking

把一个数组最开始的若干个元素搬到数组的末尾，我们称之为数组的旋转。 输入一个非减排序的数组的一个旋转，输出旋转数组的最小元素。 例如数组{3,4,5,1,2}为{1,2,3,4,5}的一个旋转，该数组的最小值为1。 NOTE：给出的所有元素都大于0，若数组大小为0，请返回0

class Solution {
public:
    int minNumberInRotateArray(vector<int> rotateArray) {
        if (rotateArray.empty())
            return 0;
        //简单粗暴，直接找最小值，先排序，判断第一个数
        sort(rotateArray.begin(), rotateArray.end());
        return rotateArray[0];
    }
};



class Solution {
public:
    int minNumberInRotateArray(vector<int> rotateArray) {
        if (rotateArray.empty())
            return 0;
        //直接排序的话，底层用的是快排，时间复杂度平均情况为 NlogN
        //使用二分查找思想，时间复杂度 logN
        //下面这个方法是直接查找最小数字的
        int left = 0;
        int right = rotateArray.size() - 1;
        while(left < right)
        {
            int mid = left + (right - left) / 2;
            if(rotateArray[mid] > rotateArray[right]) // 说明一定在右边
                left = mid + 1;
            else if(rotateArray[mid] == rotateArray[right]) //此时最小数字不好判断在mid左边还是右边,这时只好一个一个试 
                --right;
            else //如果待查询的范围最后只剩两个数，那么mid 一定会指向下标靠前的数字
                right = mid;
        }
        return rotateArray[left];
    }
};



class Solution {
public:
    int minNumberInRotateArray(vector<int> rotateArray) {
        if (rotateArray.empty())
            return 0;
        //直接排序的话，底层用的是快排，时间复杂度平均情况为 NlogN
        //使用二分查找思想，时间复杂度 logN
        //下面这个方法判断区间是否是递增区间的
        int left = 0;
        int right = rotateArray.size() - 1;
        while (left < right)
        {
            //确认子数组是否是类似1,1,2,4,5,..,7的非递减数组,避免错过直接有序情况
            if (rotateArray[left] < rotateArray[right])
                return rotateArray[left];
             
            int mid = left + (right - left) / 2;
            //如果左半数组为有序数组
            if (rotateArray[left] < rotateArray[mid])
                left = mid + 1;  // 左区间不包含最小
            //如果右半数组为有序数组
            else if (rotateArray[mid] < rotateArray[right])
                right = mid; //左区间包含最小的
            //否则，rotateArray[left] == rotateArray[mid] == rotateArray[right]
            else //得一个一个判断
                ++left;
        }
        return rotateArray[left];
    }
};



4、变态跳台阶
https://www.nowcoder.com/practice/22243d016f6b47f2a6928b4313c85387?tpId=13&tqId=11162&tPage=1&rp=1&ru=%2Fta%2Fcoding-interviews&qru=%2Fta%2Fcoding-interviews%2Fquestion-ranking

一只青蛙一次可以跳上1级台阶，也可以跳上2级……它也可以跳上n级。求该青蛙跳上一个n级的台阶总共有多少种跳法。

class Solution {
public:
    int jumpFloorII(int number) {
        //方法一： 找规律
        //return pow(2, number - 1);
        //return 1 << (number - 1);
        
        //方法二：递归计算
        if(number == 0)
            return 1;
         int count = 0;
        for(int i = 1; i <= number; ++i){
            count += jumpFloorII(number - i);
        }
        return count;
    }
};